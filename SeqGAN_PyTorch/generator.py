# -*- coding: utf-8 -*-

import os
import random

import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> d083f639ce45b5e56f8fe2ed8676259f23ca06f1
from torch.distributions import Categorical

class Generator(nn.Module):
    """Generator """
    def __init__(self, num_emb, batch_size, emb_dim, hidden_dim, num_classes, use_cuda,
                 sequence_length, start_token, learning_rate=0.001, reward_gamma=0.95, grad_clip=5.0):
        super(Generator, self).__init__()
        self.num_emb = num_emb
        self.batch_size = batch_size
        self.emb_dim = emb_dim
        self.hidden_dim = hidden_dim
        self.use_cuda = use_cuda
        self.sequence_length = sequence_length
        self.start_token = start_token
        self.learning_rate = learning_rate
        self.reward_gamma = reward_gamma
        self.grad_clip = grad_clip
<<<<<<< HEAD
=======
=======

class Generator(nn.Module):
    """Generator """
    def __init__(self, num_emb, emb_dim, hidden_dim, num_classes, use_cuda,
                 sequence_length, start_token, learning_rate=0.001, reward_gamma=0.95, grad_clip=5.0):
        super(Generator, self).__init__()
        self.num_emb = num_emb
        self.emb_dim = emb_dim
        self.hidden_dim = hidden_dim
        self.use_cuda = use_cuda
>>>>>>> b594693170c35e64bbff3b586c9d8a6b2a38966b
>>>>>>> d083f639ce45b5e56f8fe2ed8676259f23ca06f1

        self.emb = nn.Embedding(num_emb, emb_dim)
        self.class_emb = nn.Embedding(num_classes, emb_dim) # Class embedding

        self.lstm = nn.LSTM(emb_dim, hidden_dim, batch_first=True)
        self.lin = nn.Linear(hidden_dim, num_emb)
        self.softmax = nn.LogSoftmax()
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> d083f639ce45b5e56f8fe2ed8676259f23ca06f1
        # self.init_params()

        self.optimizer = torch.optim.Adam(self.parameters(), lr=learning_rate)

    def init_hidden(self, batch_size):
        h = Variable(torch.zeros((1, batch_size, self.hidden_dim)))
        c = Variable(torch.zeros((1, batch_size, self.hidden_dim)))
        if self.use_cuda:
            h, c = h.cuda(), c.cuda()
        return h, c

    # def init_params(self):
    #     for param in self.parameters():
    #         param.data.uniform_(-0.05, 0.05)
    
    def forward(self, x, class_label, hidden):
<<<<<<< HEAD
=======
=======
        self.init_params()

    def forward(self, x, class_label):
>>>>>>> b594693170c35e64bbff3b586c9d8a6b2a38966b
>>>>>>> d083f639ce45b5e56f8fe2ed8676259f23ca06f1
        """
        Args:
            x: (batch_size, seq_len), sequence of tokens generated by generator
            class_label: (batch_size, ), class label for the sequences
        """
        emb = self.emb(x) # (batch_size, seq_len, emb_dim)

        # Embedding for class labels and expand to match sequence length
        class_emb = self.class_emb(class_label).unsqueeze(1)  # (batch_size, 1, emb_dim)
        class_emb = class_emb.expand(-1, x.size(1), -1)       # (batch_size, seq_len, emb_dim)
        # Concatenate token embeddings with class embeddings
        combined_emb = torch.cat([emb, class_emb], dim=-1)  # (batch_size, seq_len, emb_dim * 2)

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> d083f639ce45b5e56f8fe2ed8676259f23ca06f1
        output, hidden = self.lstm(combined_emb, hidden)
        pred = self.lin(output.contiguous().view(-1, self.hidden_dim))
        return pred.view(x.size(0), x.size(1), -1), hidden
        #return pred

    def generate(self, class_label):
        """
        Generates a batch of samples along with their class labels.
        """
        # Initialize input and hidden states
        gen_x = torch.zeros(self.batch_size, self.sequence_length).long()
        hidden = self.init_hidden()

        # Start token input
        x = torch.tensor([self.start_token] * self.batch_size).unsqueeze(1)  # [batch_size, 1]
        if self.use_cuda:
            x = x.cuda()
            gen_x = gen_x.cuda()

        # Generate sequence
        for i in range(self.sequence_length):
            logits, hidden = self.forward(x, class_label, hidden)
            probs = F.softmax(logits[:, -1, :], dim=-1)  # [batch_size, num_emb]
            next_token = Categorical(probs).sample().unsqueeze(1)  # [batch_size, 1]
            gen_x[:, i] = next_token.squeeze()
            x = next_token

        return gen_x

    def pretrain_step(self, x, class_label):
        """
        Performs a pretraining step on the generator.
        Also known as supervised pretraining.
        """
        self.train()
        hidden = self.init_hidden(x.size(0))
        self.optimizer.zero_grad()

        # Forward pass
        logits, _ = self.forward(x, class_label, hidden)
        logits = logits.view(-1, self.num_emb)  # [batch_size * seq_len, num_emb]
        target = x.view(-1)  # [batch_size * seq_len]

        # Calculate loss
        loss = F.cross_entropy(logits, target)

        # Backward pass
        loss.backward()
        torch.nn.utils.clip_grad_norm_(self.parameters(), self.grad_clip)
        self.optimizer.step()

        return loss.item()

    def train_step(self, x, class_label, rewards):
        """
        Performs a training step on the generator.
        Also known as unsupervised training.
        """
        self.train()
        hidden = self.init_hidden(x.size(0))
        self.optimizer.zero_grad()

        # Forward pass
        logits, _ = self.forward(x, class_label, hidden)
        logits = logits.view(-1, self.num_emb)  # [batch_size * seq_len, num_emb]
        target = x.view(-1)  # [batch_size * seq_len]

        # Calculate loss with rewards
        log_probs = F.log_softmax(logits, dim=-1)
        one_hot = F.one_hot(target, self.num_emb).float()
        loss = -torch.sum(rewards.view(-1, 1) * one_hot * log_probs) / self.batch_size

        # Backward pass
        loss.backward()
        torch.nn.utils.clip_grad_norm_(self.parameters(), self.grad_clip)
        self.optimizer.step()

        return loss.item()

    # def step(self, x, class_label, h, c):
    #     """
    #     Args:
    #         x: (batch_size,  1), sequence of tokens generated by generator
    #         class_label: (batch_size, ), class label for the sequences
    #         h: (1, batch_size, hidden_dim), lstm hidden state
    #         c: (1, batch_size, hidden_dim), lstm cell state
    #     """
    #     emb = self.emb(x)

    #     # Class embedding
    #     class_emb = self.class_emb(class_label).unsqueeze(1)  # (batch_size, 1, emb_dim)
        
    #     # Concatenate token embedding with class embedding
    #     combined_emb = torch.cat([emb, class_emb], dim=-1)  # (batch_size, 1, emb_dim * 2)
  
    #     output, (h, c) = self.lstm(combined_emb, (h, c))
    #     pred = F.softmax(self.lin(output.view(-1, self.hidden_dim)), dim=1)
    #     return pred, h, c

    # def sample(self, batch_size, seq_len, class_label, x=None):
    #     res = []
    #     flag = False # whether sample from zero
    #     if x is None:
    #         flag = True
    #     if flag:
    #         x = Variable(torch.zeros((batch_size, 1)).long())
    #     if self.use_cuda:
    #         x = x.cuda()
    #     h, c = self.init_hidden(batch_size)
    #     samples = []
    #     if flag:
    #         for i in range(seq_len):
    #             output, h, c = self.step(x, class_label, h, c)
    #             x = output.multinomial(1)
    #             samples.append(x)
    #     else:
    #         given_len = x.size(1)
    #         lis = x.chunk(x.size(1), dim=1)
    #         for i in range(given_len):
    #             output, h, c = self.step(lis[i], class_label, h, c)
    #             samples.append(lis[i])
    #         x = output.multinomial(1)
    #         for i in range(given_len, seq_len):
    #             samples.append(x)
    #             output, h, c = self.step(x, class_label, h, c)
    #             x = output.multinomial(1)
    #     output = torch.cat(samples, dim=1)
    #     return output
<<<<<<< HEAD
=======
=======
        h0, c0 = self.init_hidden(x.size(0))
        output, (h, c) = self.lstm(combined_emb, (h0, c0))
        pred = self.softmax(self.lin(output.contiguous().view(-1, self.hidden_dim)))
        return pred.view(x.size(0), x.size(1), -1)
        #return pred

    def step(self, x, class_label, h, c):
        """
        Args:
            x: (batch_size,  1), sequence of tokens generated by generator
            class_label: (batch_size, ), class label for the sequences
            h: (1, batch_size, hidden_dim), lstm hidden state
            c: (1, batch_size, hidden_dim), lstm cell state
        """
        emb = self.emb(x)

        # Class embedding
        class_emb = self.class_emb(class_label).unsqueeze(1)  # (batch_size, 1, emb_dim)
        
        # Concatenate token embedding with class embedding
        combined_emb = torch.cat([emb, class_emb], dim=-1)  # (batch_size, 1, emb_dim * 2)
  
        output, (h, c) = self.lstm(combined_emb, (h, c))
        pred = F.softmax(self.lin(output.view(-1, self.hidden_dim)), dim=1)
        return pred, h, c


    def init_hidden(self, batch_size):
        h = Variable(torch.zeros((1, batch_size, self.hidden_dim)))
        c = Variable(torch.zeros((1, batch_size, self.hidden_dim)))
        if self.use_cuda:
            h, c = h.cuda(), c.cuda()
        return h, c

    def init_params(self):
        for param in self.parameters():
            param.data.uniform_(-0.05, 0.05)

    def sample(self, batch_size, seq_len, class_label, x=None):
        res = []
        flag = False # whether sample from zero
        if x is None:
            flag = True
        if flag:
            x = Variable(torch.zeros((batch_size, 1)).long())
        if self.use_cuda:
            x = x.cuda()
        h, c = self.init_hidden(batch_size)
        samples = []
        if flag:
            for i in range(seq_len):
                output, h, c = self.step(x, class_label, h, c)
                x = output.multinomial(1)
                samples.append(x)
        else:
            given_len = x.size(1)
            lis = x.chunk(x.size(1), dim=1)
            for i in range(given_len):
                output, h, c = self.step(lis[i], class_label, h, c)
                samples.append(lis[i])
            x = output.multinomial(1)
            for i in range(given_len, seq_len):
                samples.append(x)
                output, h, c = self.step(x, class_label, h, c)
                x = output.multinomial(1)
        output = torch.cat(samples, dim=1)
        return output
>>>>>>> b594693170c35e64bbff3b586c9d8a6b2a38966b
>>>>>>> d083f639ce45b5e56f8fe2ed8676259f23ca06f1
