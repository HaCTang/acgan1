# -*- coding: utf-8 -*-

import os
import random

import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable
from torch.distributions import Categorical
from torch.nn.utils.rnn import pack_padded_sequence, pad_packed_sequence

class Generator(nn.Module):
    """Generator """
    def __init__(self, vocab_size, batch_size, seq_emb_dim, class_emb_dim, hidden_dim, num_classes, use_cuda,
                 sequence_length, start_token, learning_rate=0.001, grad_clip=5):
        super(Generator, self).__init__()
        self.vocab_size = vocab_size
        self.batch_size = batch_size
        self.seq_emb_dim = seq_emb_dim
        self.class_emb_dim = class_emb_dim

        self.hidden_dim = hidden_dim
        self.use_cuda = use_cuda
        self.sequence_length = sequence_length
        self.start_token = torch.tensor([start_token] * self.batch_size, dtype=torch.long) # (batch_size, )
        self.learning_rate = learning_rate
        self.grad_clip = grad_clip
        self.temperature = 1.0

        self.seq_emb = nn.Embedding(vocab_size, seq_emb_dim)
        self.class_emb = nn.Embedding(num_classes, class_emb_dim)

        self.seq_lstm = nn.LSTM(seq_emb_dim, hidden_dim, num_layers=2, batch_first=True)
        
        self.lin = nn.Linear(hidden_dim, vocab_size)

        self.optimizer = torch.optim.Adam(self.parameters(), lr=learning_rate)
        # nn.init.normal_(self.seq_emb.weight, std=0.1)
        self.init_params()

    def init_hidden(self, batch_size):
        h = Variable(torch.zeros((2, batch_size, self.hidden_dim)))
        c = Variable(torch.zeros((2, batch_size, self.hidden_dim)))
        if self.use_cuda:
            h, c = h.cuda(), c.cuda()
        return (h, c)

    def init_params(self):
        for param in self.parameters():
            param.data.normal_(0, 0.1)

    def forward(self, x, class_label, seq_hidden, label_input=False):
        """
        Args:
            x: (batch_size, seq_len), sequence of tokens generated by generator
            class_label: (batch_size, ), class label for the sequences
        """
        x = x.to(self.seq_emb.weight.device)
        seq_hidden = tuple(h.to(self.seq_emb.weight.device) for h in seq_hidden)
        # if label_input:
        #     # 将start token与class label相乘
        #     start_token = torch.mul(self.start_token, class_label) # (batch_size, )
        # else:
        #     start_token = torch.tensor([0] * self.batch_size, dtype=torch.long) # (batch_size, )
        # x = torch.cat([start_token.unsqueeze(1), x], dim=1)        
        x_emb = self.seq_emb(x) # (batch_size, seq_len+1, emb_dim)
        seq_output, seq_hidden = self.seq_lstm(x_emb, seq_hidden)
        combined_output = seq_output
        logits = self.lin(combined_output.contiguous().view(-1, self.hidden_dim))
        logits = logits.view(x.size(0), x.size(1), -1)

        return logits, class_label, seq_hidden


    def pretrain_loss(self, x):
        """
        Calculates the pretraining loss.
        x: (batch_size, seq_len)
        logits: (batch_size, seq_len, vocab_size)
        """
        seq_hidden = self.init_hidden(x.size(0))
        x = x.to(self.seq_emb.weight.device)
        seq_hidden = tuple(h.to(self.seq_emb.weight.device) for h in seq_hidden)
        logits, _, _ = self.forward(x, None, seq_hidden, label_input=False) # (batch_size, seq_len + 1, vocab_size)
        # #去除start token
        # logits = logits[:, 1:, :]
        labels = x.detach().clone()    
        labels = labels[:, 1:].contiguous().view(-1)  # (batch_size * seq_len)
        logits = logits[:, :-1, :].contiguous().view(-1, self.vocab_size)  # (batch_size * seq_len, vocab_size)
        # loss = F.cross_entropy(logits, labels, ignore_index=-100)
        log_probs = F.log_softmax(logits, dim=-1)
        log_probs = log_probs.view(-1, self.vocab_size)
        target = labels.view(-1)
        one_hot = F.one_hot(target, num_classes=self.vocab_size).float()
        loss = -torch.sum(one_hot * log_probs) / (self.batch_size * self.sequence_length)
        return loss

    def pretrain_step(self, x):
        """
        Performs a pretraining step without class label.
        """
        self.optimizer.zero_grad()
        loss = self.pretrain_loss(x)
        loss.backward()

        torch.nn.utils.clip_grad_norm_(self.parameters(), self.grad_clip)
        self.optimizer.step()
        return loss.item()

    def train_loss(self, x, class_label, rewards):
        """
        Calculates the generator loss with rewards.
        """
        hidden = self.init_hidden(x.size(0))
        x = x.to(self.seq_emb.weight.device)
        class_label = class_label.to(self.seq_emb.weight.device)
        rewards = rewards.to(self.seq_emb.weight.device)
        hidden = tuple(h.to(self.seq_emb.weight.device) for h in hidden)
        logits, _, _ = self.forward(x, class_label, hidden, label_input=True)
        # logits = logits[:, 1:, :]
        
        labels = x.detach().clone()
        labels = labels[:, 1:].contiguous().view(-1)  # (batch_size * (seq_len - 1))
        logits = logits[:, :-1, :].contiguous().view(-1, self.vocab_size)  # (batch_size * (seq_len - 1), vocab_size)
        
        rewards = rewards[:, 1:].contiguous().view(-1)  # Ensure rewards match the size of labels

        log_probs = F.log_softmax(logits, dim=-1)
        log_probs = log_probs.view(-1, self.vocab_size)
        target = labels.view(-1)
        one_hot = F.one_hot(target, num_classes=self.vocab_size).float()
        selected_log_prob = torch.sum(one_hot * log_probs, dim=-1)
        rewards = rewards.reshape(-1)
        logits_loss = -torch.sum(selected_log_prob * rewards) / (self.batch_size * self.sequence_length)

        # #Calculate classification loss
        # class_logits = class_logits.view(-1, self.num_classes)
        # class_labels = class_label.view(-1)
        # class_loss = F.cross_entropy(class_logits, class_labels)

        loss = logits_loss #+ class_loss

        return loss

    def train_step(self, x, class_label, rewards):
        """
        Performs a training step with class label.
        """
        self.optimizer.zero_grad()
        loss = self.train_loss(x, class_label, rewards)
        loss.backward()
        torch.nn.utils.clip_grad_norm_(self.parameters(), self.grad_clip)
        self.optimizer.step()
        return loss.item()

    def generate(self, class_label, label_input=False): 
        """
        Generates a batch of samples along with their class labels.
        """
        seq_hidden = self.init_hidden(self.batch_size)
        if label_input:
            start_token = torch.mul(self.start_token, class_label) # (batch_size, )
            x = start_token.unsqueeze(1).to(self.seq_emb.weight.device)  # [batch_size, 1]
        else:
            x = self.start_token.unsqueeze(1).to(self.seq_emb.weight.device)  # [batch_size, 1]
        if self.use_cuda:
            seq_hidden = tuple(h.cuda() for h in seq_hidden)

        samples = []
        # is_end = torch.zeros(self.batch_size, dtype=torch.bool, device=x.device)  # Initialize is_end as False
        with torch.no_grad():
            for _ in range(self.sequence_length):
                if label_input:
                    logits, _, seq_hidden = self.forward(x, class_label, seq_hidden, label_input=True)
                else:
                    logits, _, seq_hidden = self.forward(x, None, seq_hidden, label_input=False)  # (batch_size, seq_len, vocab_size)
                probs = F.softmax(logits[:, -1, :] / self.temperature, dim=-1)  # [batch_size, vocab_size]
                next_token = torch.multinomial(probs, 1).squeeze()  # [batch_size]
                samples.append(next_token)
                x = next_token.unsqueeze(1)  # [batch_size, 1]
        samples = torch.stack(samples, dim=1)
        first_pad_token = (samples == self.vocab_size - 1).to(torch.long)
        first_pad_token = torch.argmax(first_pad_token, dim=-1)
        for i in range(first_pad_token.size(0)):
            if first_pad_token[i] < self.sequence_length - 1:
                samples[i, first_pad_token[i]+1:] = self.vocab_size - 1
        return samples, class_label
    
    # def get_reward(self, input_x, class_label, rollout_num, dis, pad_num, reward_fn=None, Dweight1=1, Dweight2=1):
    #     """Calculates the rewards for a list of SMILES strings."""
    #     reward_weight1 = 1 - Dweight1
    #     rewards = [0] * (self.sequence_length)
    #     hidden = self.init_hidden(self.batch_size)
    #     for _ in range(rollout_num):
    #         already = []
    #         for given_num in range(1, input_x.size(1) + 1):  # Update loop range to avoid out of bounds
    #             gen_x = []
    #             logits, _, hidden = self.forward(input_x[:, :given_num], class_label, hidden)  # Use only the part of the sequence generated so far
    #             for i in range(given_num):
    #                 gen_x.append(input_x[:, i])
    #             for i in range(given_num, self.sequence_length):
    #                 if i == given_num:
    #                     x_t = self.combined_emb[:, i - 1, :]
    #                 else:
    #                     next_token = next_token.unsqueeze(1)
    #                     token_emb = self.seq_emb(next_token).squeeze(1)
    #                     class_emb_current = self.class_emb(class_label).squeeze(1)
    #                     x_t = torch.cat([token_emb, class_emb_current], dim=-1)
    #                 x_t = x_t.unsqueeze(1)  # Add batch dimension
    #                 _, hidden = self.seq_lstm(x_t, hidden)
    #                 o_t = self.lin(hidden[0].squeeze(0))
    #                 log_prob = F.log_softmax(o_t, dim=-1)
    #                 next_token = torch.multinomial(log_prob.exp(), 1).squeeze()
    #                 gen_x.append(next_token)
    #             generated_seqs = torch.stack(gen_x, dim=1)

    #             gind = np.array(range(len(generated_seqs)))
                
    #             dis_output = dis(generated_seqs.to(dis.emb.weight.device))
    #             if isinstance(dis_output, tuple):
    #                 ypred_for_auc, yclasspred_for_auc = dis_output
    #             else:
    #                 ypred_for_auc = dis_output
    #                 yclasspred_for_auc = None

    #             if yclasspred_for_auc is not None:
    #                 yclasspred_for_auc = yclasspred_for_auc.detach()
    #             ypred_for_auc = ypred_for_auc.detach()
                
    #             ypred = ypred_for_auc.clone()
    #             yclasspred = yclasspred_for_auc.clone() if yclasspred_for_auc is not None else None
                
    #             if reward_fn:
    #                 ypred = Dweight1 * ypred
    #                 rew = reward_fn(generated_seqs.cpu().numpy())
                    
    #                 for k, r in zip(gind, rew):
    #                     ypred[k] += reward_weight1 * r

    #                 for j, k in enumerate(gind):
    #                     if input_x[k, given_num - 1] == pad_num and (given_num == 1 or input_x[k, given_num - 2] == pad_num):
    #                         already.append((k, rew[j]))

    #                 already = sorted(already, key=lambda el: el[0])

    #             if len(rewards) == 0:
    #                 rewards.append(ypred)
    #             else:
    #                 rewards[given_num - 1] += ypred
            
    #         dis_output = dis(input_x.to(dis.emb.weight.device))
    #         if isinstance(dis_output, tuple):
    #             ypred_for_auc, yclasspred_for_auc = dis_output
    #         else:
    #             ypred_for_auc = dis_output
    #             yclasspred_for_auc = None
    #         yclasspred_for_auc = yclasspred_for_auc.detach() if yclasspred_for_auc is not None else None
    #         ypred_for_auc = ypred_for_auc.detach()
            
    #         if reward_fn:
    #             input_x_list = input_x.cpu().tolist()
    #             ypred = Dweight1 * ypred_for_auc + reward_weight1 * torch.tensor(reward_fn(input_x_list).reshape(-1, 1), device=ypred_for_auc.device, dtype=ypred_for_auc.dtype)
    #         else:
    #             ypred = ypred_for_auc
            
    #         if len(rewards) == 0:
    #             rewards.append(ypred)
    #         else:
    #             rewards[-1] += ypred
        
    #     rewards = np.transpose(np.array([reward.cpu().numpy() for reward in rewards])) / (1.0 * rollout_num)  # batch_size x seq_length
    #     flattened_rewards = rewards[0]
    #     return flattened_rewards



