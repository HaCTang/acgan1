# -*- coding: utf-8 -*-

import os
import random

import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable

class TargetLSTM(nn.Module):
    """Target Lstm """
    def __init__(self, num_emb, emb_dim, hidden_dim, num_classes, use_cuda):
        super(TargetLSTM, self).__init__()
        self.num_emb = num_emb
        self.emb_dim = emb_dim
        self.hidden_dim = hidden_dim
        self.num_classes = num_classes
        self.use_cuda = use_cuda
        
        # Token and class embedding layers
        self.emb = nn.Embedding(num_emb, emb_dim)
        self.class_emb = nn.Embedding(num_classes, emb_dim)
        
        # LSTM for sequence generation
        self.lstm = nn.LSTM(emb_dim * 2, hidden_dim, batch_first=True)  # Concatenate token and class embeddings
        self.lin = nn.Linear(hidden_dim, num_emb)
        self.softmax = nn.LogSoftmax(dim=-1)
        
        self.init_params()

    def forward(self, x, class_label):
        """
        Args:
            x: (batch_size, seq_len), sequence of tokens generated by generator
            class_label: (batch_size,), class label for conditional generation
        """
        emb = self.emb(x)
        
        # Get class embedding and expand to match sequence length
        class_emb = self.class_emb(class_label).unsqueeze(1)  # (batch_size, 1, emb_dim)
        class_emb = class_emb.expand(-1, x.size(1), -1)       # (batch_size, seq_len, emb_dim)
        
        # Concatenate token embeddings with class embeddings
        combined_emb = torch.cat([emb, class_emb], dim=-1)  # (batch_size, seq_len, emb_dim * 2)
        
        h0, c0 = self.init_hidden(x.size(0))
        output, (h, c) = self.lstm(combined_emb, (h0, c0))  # Pass through LSTM
        
        pred = self.softmax(self.lin(output.contiguous().view(-1, self.hidden_dim)))
        return pred.view(x.size(0), x.size(1), -1)

    def step(self, x, class_label, h, c):
        """
        Args:
            x: (batch_size, 1), sequence of tokens generated by generator
            class_label: (batch_size,), class label for conditional generation
            h: (1, batch_size, hidden_dim), lstm hidden state
            c: (1, batch_size, hidden_dim), lstm cell state
        """
        emb = self.emb(x)  # (batch_size, 1, emb_dim)
        
        # Class embedding
        class_emb = self.class_emb(class_label).unsqueeze(1)  # (batch_size, 1, emb_dim)
        
        # Concatenate token embedding with class embedding
        combined_emb = torch.cat([emb, class_emb], dim=-1)  # (batch_size, 1, emb_dim * 2)
        
        output, (h, c) = self.lstm(combined_emb, (h, c))
        pred = F.softmax(self.lin(output.view(-1, self.hidden_dim)), dim=1)
        return pred, h, c

    def init_hidden(self, batch_size):
        h = Variable(torch.zeros((1, batch_size, self.hidden_dim)))
        c = Variable(torch.zeros((1, batch_size, self.hidden_dim)))
        if self.use_cuda:
            h, c = h.cuda(), c.cuda()
        return h, c

    def init_params(self):
        for param in self.parameters():
            param.data.normal_(0, 1)

    def sample(self, batch_size, seq_len, class_label):
        """
        Sample sequences conditionally based on class_label.
        
        Args:
            batch_size: Number of sequences to generate
            seq_len: Length of sequences
            class_label: (batch_size,), class labels for conditional generation
        """
        with torch.no_grad():
            x = Variable(torch.zeros((batch_size, 1)).long())
            if self.use_cuda:
                x = x.cuda()
            h, c = self.init_hidden(batch_size)
            samples = []
            for i in range(seq_len):
                output, h, c = self.step(x, class_label, h, c)
                x = output.multinomial(1)
                samples.append(x)
            output = torch.cat(samples, dim=1)
            return output
        return None
